package comp1140.ass2;import comp1140.ass2.dataStructure.*;import comp1140.ass2.gui.PCG;import comp1140.ass2.gui.dataStructure.JustData;import java.util.*;/** * Agamemnon Game engine * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved */public class AgamemnonState{    private static final int EdgeCollectionsInitialCapacity = 55;    private static final int TileCollectionsInitialCapacity = 35;    public final HashSet<Integer> tileStateEffectKeySet = new HashSet<>(TileCollectionsInitialCapacity);        // Effective means no weft; for calculating total score algorithm        // From the perspective of Strength and Leadership edges, weft behaves as if there is no tile there    public final HashMap<Integer, Tile> tileState = new HashMap<>(TileCollectionsInitialCapacity);        // Technically the it is redundant to use Map (tile.nodeID = key)        // But using it allows faster access/linking/finding tiles and used nodes    public final ArrayList<Tile> tileStateOrdered = new ArrayList<>(TileCollectionsInitialCapacity);    public final HashSet<Edge> edgeState = new HashSet<>(EdgeCollectionsInitialCapacity);    public static final TileKind[] tilesAvailable = new TileKind[] { // total number of Tiles available                TileKind.A            ,   TileKind.B            ,   TileKind.C            ,   TileKind.D            ,   TileKind.E            ,   TileKind.F,   TileKind.F,   TileKind.F            ,   TileKind.G,   TileKind.G            ,   TileKind.H            ,   TileKind.I,   TileKind.I            ,   TileKind.J,   TileKind.J    };    // Available location for generateAction function    public final ArrayList<TileKind> blackAvailable = new ArrayList<>(Arrays.asList(tilesAvailable));    public final ArrayList<TileKind> orangeAvailable = new ArrayList<>(Arrays.asList(tilesAvailable));    // Matrix representing the undirected graph (node connections) with entries being EdgeType    // This thing is extremely important as it allows incredible fast edge finding speed (finding warp actions)    public final EdgeType[][] matrixEdgeEncode;    public final int maxNodeID; // 31 for normal, 32 for Loom    public final ArrayList<Integer> availableNodes = new ArrayList<>(TileCollectionsInitialCapacity);    public final boolean activateLOOM; // for the viewers only... because that's the only place where I hardcoded stuff.    public static AgamemnonState getNew(boolean activateLOOM){        Random rand = new Random();        int seed = rand.nextInt(2000);        System.out.println("The PCG mutation broad is " + PCG.randomMutationPCGState(seed));        return activateLOOM ?                new AgamemnonState(new String[] {"", Utility.randomLoomEdgeState()}) :                new AgamemnonState(new String[] {"", PCG.randomMutationPCGState(seed)});//                new AgamemnonState(new String[] {"", JustData.standardAgam}) ;    }    public static AgamemnonState getNew(boolean activateLOOM, long seed){        return activateLOOM ?                new AgamemnonState(new String[] {"", Utility.randomLoomEdgeState(seed)}) ://                new AgamemnonState(new String[] {"", PCG.randomMutationPCGState(seed)}) :                new AgamemnonState(new String[] {"", JustData.standardAgam}) ;    }    /**     * Converts from the String[] state to State using HashSet and much more!     * We assume that the given state string is well formed and valid!     * @param state normal String[] state     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public AgamemnonState(String[] state){        String strTileState = state[0];        String strEdgeState = state[1];        // Need to get maxNodeID (could just use = 31, but I want this to be as general as possible)        int maxNodeID = 0; // which should be the number of nodes (n-1)        int endpointA, endpointB;        for (int i = 0; i < strEdgeState.length(); i += 5) {            endpointA = ((int) strEdgeState.charAt(i + 1) - 48) * 10 + ((int) strEdgeState.charAt(i + 2) - 48);            endpointB = ((int) strEdgeState.charAt(i + 3) - 48) * 10 + ((int) strEdgeState.charAt(i + 4) - 48);            if (endpointA > maxNodeID) maxNodeID = endpointA;            if (endpointB > maxNodeID) maxNodeID = endpointB;        }        this.maxNodeID = maxNodeID;        for (int i = 0; i < maxNodeID + 1; i++){ availableNodes.add(i); } // fill available nodes list        // Loop over to convert Tiles        Tile tempTile;        for (int i = 0; i < strTileState.length(); i += 4){            tempTile = new Tile(strTileState.substring(i, i+4));            this.tileState.put(tempTile.nodeID, tempTile);            this.tileStateOrdered.add(tempTile);            if (tempTile.tileKind != TileKind.I) { tileStateEffectKeySet.add(tempTile.nodeID); }            availableNodes.remove(Integer.valueOf(tempTile.nodeID));            if (strTileState.charAt(i) == 'O'){                this.orangeAvailable.remove(Tile.charToTileKind(strTileState.charAt(i+1)));            }else { // if (strTileState.charAt(i) == 'B'){                this.blackAvailable.remove(Tile.charToTileKind(strTileState.charAt(i+1)));            }            if (tempTile.nodeID > maxNodeID) { maxNodeID = tempTile.nodeID; }        }        // Loop over to convert Edges        int strEdgeStateLength = strEdgeState.length();        this.matrixEdgeEncode = new EdgeType[maxNodeID + 1][maxNodeID + 1];        Edge tempEdge;        boolean isLoom = false;        for (int i = 0; i < strEdgeStateLength; i += 5){            tempEdge = new Edge(strEdgeState.substring(i, i+5));            this.edgeState.add(tempEdge);            matrixEdgeEncode[tempEdge.nodeIDA][tempEdge.nodeIDB] = tempEdge.edgeType;            matrixEdgeEncode[tempEdge.nodeIDB][tempEdge.nodeIDA] = tempEdge.edgeType;            if (!(  tempEdge.edgeType == EdgeType.STRENGTH ||                    tempEdge.edgeType == EdgeType.LEADERSHIP ||                    tempEdge.edgeType == EdgeType.FORCE            )){ isLoom = true; }        }        this.activateLOOM = isLoom;    }    /**     * Constructor used for cloneIt     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public AgamemnonState(            HashSet<Integer> tileStateEffectKeySet,            HashMap<Integer, Tile> tileState,            ArrayList<Tile> tileStateOrdered,            HashSet<Edge> edgeState,            ArrayList<TileKind> blackAvailable,            ArrayList<TileKind> orangeAvailable,            ArrayList<Integer> availableNodes,            EdgeType[][] matrixEdgeEncode,            int maxNodeID,            boolean activateLOOM    ){        this.tileStateEffectKeySet.addAll(tileStateEffectKeySet);        this.tileState.putAll(tileState);        this.tileStateOrdered.addAll(tileStateOrdered);        this.edgeState.addAll(edgeState);        this.blackAvailable.clear();        this.blackAvailable.addAll(blackAvailable);        this.orangeAvailable.clear();        this.orangeAvailable.addAll(orangeAvailable);        this.availableNodes.addAll(availableNodes);        this.matrixEdgeEncode = Arrays.stream(matrixEdgeEncode).map(EdgeType[]::clone).toArray(EdgeType[][]::new);        this.maxNodeID = maxNodeID;        this.activateLOOM = activateLOOM;    }    /**     * Checks if the two AgamemnonState are equal     * @param other the other AgamemnonState     * @return true if equal, false otherwise     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public boolean equals(AgamemnonState other){        return (this.tileStateEffectKeySet.equals(other.tileStateEffectKeySet)            &&  this.tileState.equals(other.tileState)            &&  this.tileStateOrdered.equals(other.tileStateOrdered)            &&  this.edgeState.equals(other.edgeState)            &&  this.blackAvailable.equals(other.blackAvailable)            &&  this.orangeAvailable.equals(other.orangeAvailable)            &&  this.availableNodes.equals(other.availableNodes)            &&  Arrays.deepEquals(this.matrixEdgeEncode, other.matrixEdgeEncode)            );    }    public AgamemnonState cloneIt() { // FIXME TODO !! find a better way than this        return new AgamemnonState(                this.tileStateEffectKeySet,                this.tileState,                this.tileStateOrdered,                this.edgeState,                this.blackAvailable,                this.orangeAvailable,                this.availableNodes,                this.matrixEdgeEncode,                this.maxNodeID,                this.activateLOOM                );    }    @Override    public String toString() { return "tileState: " + tileState.toString() + ", edgeState: " + edgeState.toString(); }    /**     * Gives back the compatible String[] of state that everyone else uses     * @return normal state with the two Strings     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public String[] toCompatibleStringList(){        StringBuilder tileStateString = new StringBuilder(300);        for (Tile tile : tileStateOrdered){            tileStateString.append(tile.toString());        }        StringBuilder edgeStateString = new StringBuilder(300);        for (Edge edge : edgeState) {            edgeStateString.append(edge.toString());        }        return new String[]{String.valueOf(tileStateString), String.valueOf(edgeStateString)};    }    /**     * @return a Mathematica compatible input for the edge connections. (used for figuring out Loom connections)     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    String mathematicaFriendly(){        StringBuilder output = new StringBuilder(300);        output.append("GraphPlot[{");        for (Edge edge : edgeState){            output.append("Style[Labeled[");            output.append(edge.nodeIDA).append(" <-> ").append(edge.nodeIDB);            output.append(", ").append(edge.edgeType.compatibleChar()).append("],");            output.append(edge.edgeType.mathematicaColour());            output.append("],");        }        output.append("}, VertexLabels -> Automatic").append(",Method -> \"SpringElectricalEmbedding\"]");        return String.valueOf(output);    }    /**     * @return if this agamemnon state is a finished state. (i.e. to more tiles available for both players)     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public boolean isFinished(){ return (this.orangeAvailable.size() == 0 && this.blackAvailable.size() == 0); }    /**     * Turn:    0 1 2 3 4 5 ... 15     * Player:  O B O B O B ... B     * @return the Turn count     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public int getCurrentTurn(){        return (tileState.size() + 1) / 2;    }    /**     * Turn:    0 1 2 3 4 5 ...     * Player:  O B O B O B ...     * @return the playing player of this agamemnon state     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public Player getCurrentPlayer(){        return getCurrentTurn() % 2 == 0 ? Player.ORANGE : Player.BLACK;    }    /**     * (Task 5)     * @return randomly selected tile(s) that are available to be placed for this turn     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    private TilesSelected actuallySelectTiles(long seed) {        int turnCounter = getCurrentTurn();        Player playerTurn = getCurrentPlayer();        ArrayList<TileKind> remaining = new ArrayList<>(playerTurn == Player.ORANGE ? orangeAvailable : blackAvailable);        if (remaining.size() == 0) throw new IllegalCallerException("Game is finished with turnCounter="+turnCounter);        if (turnCounter < 4){ // if this is the first two turns (O,B,O,B) then no wavers tiles            while (remaining.contains(TileKind.J)) { remaining.remove(TileKind.J); }            while (remaining.contains(TileKind.I)) { remaining.remove(TileKind.I); }        }        Random random = new Random(seed);        TileKind firstSelection = remaining.get(random.nextInt(remaining.size()));        TilesSelected tilesSelected;        if (turnCounter == 0 || remaining.size() == 1){ // one tile            tilesSelected = new TilesSelected(firstSelection, playerTurn);        } else {            remaining.remove(firstSelection);            TileKind secondSelection = remaining.get(random.nextInt(remaining.size()));            tilesSelected = new TilesSelected(firstSelection, secondSelection, playerTurn);        }        return tilesSelected;    }    public TilesSelected selectTiles() { return this.actuallySelectTiles(System.currentTimeMillis()); }    public TilesSelected selectTiles(long seed){ return this.actuallySelectTiles(seed); }    /**     * Given a playing action, calculate the updated game state.     * (Task 07)     * Assuming all the inputs are okay     * @param action Action (the object version)     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public void applyAction(Action action){        applyThisAction(action.subActionA);        if (action.subActionB != null){ applyThisAction(action.subActionB); }    }    /**     * Apply ONE action (using sub-action)     * @param subAction the sub-action (single action) to be applied     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    private void applyThisAction(Action.SubAction subAction){        if (subAction.isWrap){            int placementID = subAction.tile.nodeID;            int warpNodeIDA = subAction.warpNodeIDA;            int warpNodeIDB = subAction.warpNodeIDB;            Set<Edge> newEdgeState = new HashSet<>(EdgeCollectionsInitialCapacity);            for (Edge edge : this.edgeState){                if (edge.isThisTheOne(placementID, warpNodeIDA)){                    newEdgeState.add(new Edge(edge.edgeType, warpNodeIDB, placementID)); // add the other edge                    matrixEdgeEncode[warpNodeIDB][placementID] = edge.edgeType;                    matrixEdgeEncode[placementID][warpNodeIDB] = edge.edgeType;                } else if (edge.isThisTheOne(placementID, warpNodeIDB)){                    newEdgeState.add(new Edge(edge.edgeType, warpNodeIDA, placementID));                    matrixEdgeEncode[warpNodeIDA][placementID] = edge.edgeType;                    matrixEdgeEncode[placementID][warpNodeIDA] = edge.edgeType;                } else {                    newEdgeState.add(edge);                }            }            edgeState.clear();            edgeState.addAll(newEdgeState);        }        tileState.put(subAction.tile.nodeID, subAction.tile);        tileStateOrdered.add(subAction.tile);        availableNodes.remove(Integer.valueOf(subAction.tile.nodeID));        if (subAction.tile.tileKind != TileKind.I){ tileStateEffectKeySet.add(subAction.tile.nodeID); }        if (subAction.tile.player == Player.ORANGE) {            orangeAvailable.remove(subAction.tile.tileKind);        }        else {            blackAvailable.remove(subAction.tile.tileKind);        }    }    /**     * @return orange score - black score     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public int getRelativeScore(){        int[] scores = getTotalScore();        return scores[0] - scores[1];    }    /**     * Given a game state, calculate the total number of edges won by each player.     * (Task 08)     * @return an array of two integers, where:     * * result[0] includes the points earned by the Orange player (player_1)     * * result[1] includes the points earned by the Black player (player_2)     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public int[] getTotalScore() {        GetStrengthScore getStrengthScore = new GetStrengthScore();        getStrengthScore.calculateEverything();        GetLeaderScore getLeaderScore = new GetLeaderScore();        getLeaderScore.calculateEverything();        GetForceScore getForceScore = new GetForceScore();        getForceScore.calculateEverything();        return new int[] {            getStrengthScore.scoreO + getLeaderScore.scoreO + getForceScore.scoreO,            getStrengthScore.scoreB + getLeaderScore.scoreB + getForceScore.scoreB        };    }    /**     * Calculates the two set of edges belongs to each of the player     * @return output.edgesO and output.edgesB are the two set of edges belong to the two players     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public EdgesBelongingsOUTPUT getEdgesBelongings() {        GetStrengthScore getStrengthScore = new GetStrengthScore();        getStrengthScore.calculateEverything();        GetLeaderScore getLeaderScore = new GetLeaderScore();        getLeaderScore.calculateEverything();        GetForceScore getForceScore = new GetForceScore();        getForceScore.calculateEverything();        final HashSet<Edge> edgesO = new HashSet<>(EdgeCollectionsInitialCapacity);        final HashSet<Edge> edgesB = new HashSet<>(EdgeCollectionsInitialCapacity);        edgesO.addAll(getStrengthScore.edgesO);        edgesB.addAll(getStrengthScore.edgesB);        edgesO.addAll(getLeaderScore.edgesO);        edgesB.addAll(getLeaderScore.edgesB);        edgesO.addAll(getForceScore.edgesO);        edgesB.addAll(getForceScore.edgesB);        return new EdgesBelongingsOUTPUT(edgesO, edgesB);    }    public static class EdgesBelongingsOUTPUT {        public final HashSet<Edge> edgesO;        public final HashSet<Edge> edgesB;        EdgesBelongingsOUTPUT(HashSet<Edge> edgesO, HashSet<Edge> edgesB){            this.edgesO = edgesO;            this.edgesB = edgesB;        }    }    /**     * This class will recursively call itself until every node is evaluated,     * and it will calculate a score (using calculateEverything), stored as instance variables.     *      scoreO - score of Player Orange     *      scoreB - score of Player Black     *     * Note: due to the different calculation methods of Strength, Leadership and Force Edges,     *       there are two similar copies of this.     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    class GetStrengthScore {        int scoreO;        int scoreB;        final Set<Integer> checkedStrength; // set of nodes already searched        final Set<Edge> edgesO = new HashSet<>(EdgeCollectionsInitialCapacity);        final Set<Edge> edgesB = new HashSet<>(EdgeCollectionsInitialCapacity);        GetStrengthScore(){            this.scoreO = 0;            this.scoreB = 0;            this.checkedStrength = new HashSet<>(EdgeCollectionsInitialCapacity);        }        @Override        public String toString() { return "O=" + scoreO + ", B=" + scoreB; }        void calculateEverything() {            for (int key : tileStateEffectKeySet){ // TODO maybe there's a better method                if (! (checkedStrength.contains(key))){                    StrengthScorePath path = new StrengthScorePath(0,0, checkedStrength,key);                    path = path.calculate();                    if      (path.strengthO > path.strengthB) {                        scoreO += path.edgeCounterStrength;                        edgesO.addAll(path.edgesOnPath);                    }                    else if (path.strengthO < path.strengthB) {                        scoreB += path.edgeCounterStrength;                        edgesB.addAll(path.edgesOnPath);                    }                    checkedStrength.addAll(path.checkedStrength);                }            }        }    }    /**     * This contains a path of Strength edges, use method calculate to initialise     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    class StrengthScorePath { // of one path only        int strengthO; // strength accumulator for Orange        int strengthB; // strength accumulator for Black        final Set<Integer> checkedStrength;        final int referenceNode;  // referencing this node and searching from here onwards        int edgeCounterStrength; // number of Strength edges in this path (the score of this path)        final Set<Edge> edgesOnPath = new HashSet<>(EdgeCollectionsInitialCapacity);        StrengthScorePath(int strengthO, int strengthB, Set<Integer> checkedStrength, int referenceNode){            this.strengthO = strengthO;            this.strengthB = strengthB;            this.checkedStrength = checkedStrength;            this.referenceNode = referenceNode;            this.checkedStrength.add(referenceNode);            Tile tempTile = tileState.get(referenceNode);  // this looks might throw an error, but should never happen            if      (tempTile.player == Player.ORANGE) {                if (tempTile.tileKind == null) this.strengthO += 1;                else                    this.strengthO += tempTile.tileKind.data.strength;            }            else if (tempTile.player == Player.BLACK)  {                if (tempTile.tileKind == null) this.strengthB += 1;                else                    this.strengthB += tempTile.tileKind.data.strength;            } // else player == null, this is used for projection score calculations        }        @Override        public String toString() { // for debugging (only really)            return strengthO + ", " + strengthB  + ", " + referenceNode + ", " + edgeCounterStrength;        }        /**         * Given a StrengthScorePath, complete the path         * @return information of a completed path         * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved         */        StrengthScorePath calculate(){            EdgeType[] row = matrixEdgeEncode[referenceNode];            EdgeType tempEdgeType;            for (int i = 0; i < maxNodeID+1; i++) {                tempEdgeType = row[i];                if (checkedStrength.contains(i)) continue;  // already searched, so skip                if (tempEdgeType != EdgeType.STRENGTH) continue;    // not the right EdgeType, so skip                edgeCounterStrength++;                edgesOnPath.add(new Edge(tempEdgeType, referenceNode, i));                if (tileStateEffectKeySet.contains(i)) { // if the node is connected then recurse down                    Tile tile = tileState.get(i);                    if (tile.tileKind == TileKind.I) continue;                    checkedStrength.add(i);                    StrengthScorePath recursive = new StrengthScorePath(strengthO, strengthB, checkedStrength, i);                    recursive = recursive.calculate();                    // using recursive information to update the current (this) info //TODO check if can do better                    checkedStrength.addAll(recursive.checkedStrength);                    edgeCounterStrength += recursive.edgeCounterStrength;                    edgesOnPath.addAll(recursive.edgesOnPath);                    strengthO = recursive.strengthO;                    strengthB = recursive.strengthB;                }            }            return this;        }    }    /**     * Class structured to calculate the score from Leadership edges     * Works similarly (pretty much exactly) like GetStrengthScore     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    class GetLeaderScore {        int scoreO;        int scoreB;        final Set<Integer> checkedLeader;        final Set<Edge> edgesO = new HashSet<>(EdgeCollectionsInitialCapacity);        final Set<Edge> edgesB = new HashSet<>(EdgeCollectionsInitialCapacity);        GetLeaderScore(){            this.scoreO = 0;            this.scoreB = 0;            this.checkedLeader = new HashSet<>(EdgeCollectionsInitialCapacity);        }        @Override        public String toString() { return "O=" + scoreO + ", B=" + scoreB; }        void calculateEverything() {            for (int key : tileStateEffectKeySet){                if (! (checkedLeader.contains(key))){  // find the next node to search                    LeaderScorePath path = new LeaderScorePath(new HashSet<>(EdgeCollectionsInitialCapacity),new HashSet<>(EdgeCollectionsInitialCapacity), checkedLeader, key);                    path = path.calculate();                    int effectiveTopO = 0;                    int effectiveTopB = 0;                    for (int score : path.leadersO){                        if (! path.leadersB.contains(score)) effectiveTopO = Math.max(score, effectiveTopO);                    }                    for (int score : path.leadersB){                        if (! path.leadersO.contains(score)) effectiveTopB = Math.max(score, effectiveTopB);                    }                    if      (effectiveTopO > effectiveTopB) {                        scoreO += path.edgeCounterLeader;                        edgesO.addAll(path.edgesOnPath);                    }                    else if (effectiveTopO < effectiveTopB) {                        scoreB += path.edgeCounterLeader;                        edgesB.addAll(path.edgesOnPath);                    }                    checkedLeader.addAll(path.checkedLeader);                }            }        }    }    /**     * This contains a path of Leadership edges, use method calculate to initialise     * Works similarly (pretty much exactly) like StrengthScorePath     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    class LeaderScorePath { // of one path only        HashSet<Integer> leadersO;        HashSet<Integer> leadersB;        final Set<Integer> checkedLeader;        final int referenceNode;        int edgeCounterLeader;        final Set<Edge> edgesOnPath = new HashSet<>(EdgeCollectionsInitialCapacity);        LeaderScorePath(HashSet<Integer> leadersO, HashSet<Integer> leadersB, Set<Integer> checkedLeader, int referenceNode){            this.leadersO = leadersO;            this.leadersB = leadersB;            this.checkedLeader = checkedLeader;            this.referenceNode = referenceNode;            this.checkedLeader.add(referenceNode);            Tile tempTile = tileState.get(referenceNode); // this looks might throw an error, but should never happen            if      (tempTile.player == Player.ORANGE) {                if (tempTile.tileKind == null) this.leadersO.add(1);                else this.leadersO.add(tempTile.tileKind.data.rank);            }            else if (tempTile.player == Player.BLACK)  {                if (tempTile.tileKind == null) this.leadersB.add(1);                else this.leadersB.add(tempTile.tileKind.data.rank);            } // else player == null, this is used for projection score calculations        }        @Override        public String toString() {return leadersO + ", " + leadersB + ", " + referenceNode + ", " + edgeCounterLeader;}        LeaderScorePath calculate(){            EdgeType[] row = matrixEdgeEncode[referenceNode];            EdgeType tempEdgeType;            LeaderScorePath recursive;            for (int i = 0; i < maxNodeID+1; i++) {                tempEdgeType = row[i];                if (checkedLeader.contains(i)) continue;                if (tempEdgeType != EdgeType.LEADERSHIP) continue;                edgeCounterLeader++;                edgesOnPath.add(new Edge(tempEdgeType, referenceNode, i));                if (tileStateEffectKeySet.contains(i)) {                    Tile tile = tileState.get(i);                    if (tile.tileKind == TileKind.I) {                        Tile referenceTile = tileState.get(referenceNode);                        if (referenceTile.tileKind == TileKind.I) edgeCounterLeader--;                        continue;                    }                    checkedLeader.add(i);                    recursive = new LeaderScorePath(leadersO, leadersB, checkedLeader, i);                    recursive = recursive.calculate();                    checkedLeader.addAll(recursive.checkedLeader);                    edgeCounterLeader += recursive.edgeCounterLeader;                    edgesOnPath.addAll(recursive.edgesOnPath);                    leadersO.addAll(recursive.leadersO);                    leadersB.addAll(recursive.leadersB);                }            }            return this;        }    }    /**     * Class structured to calculate the score from Force edges     * Works similarly (pretty much exactly) like GetStrengthScore     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    class GetForceScore {        int scoreO;        int scoreB;        final Set<Integer> checkedForce;        final Set<Edge> edgesO = new HashSet<>(EdgeCollectionsInitialCapacity);        final Set<Edge> edgesB = new HashSet<>(EdgeCollectionsInitialCapacity);        GetForceScore(){            this.scoreO = 0;            this.scoreB = 0;            this.checkedForce = new HashSet<>(EdgeCollectionsInitialCapacity);        }        @Override        public String toString() { return "O=" + scoreO + ", B=" + scoreB; }        void calculateEverything() {            Set<Integer> refinedTileStateKeySet = new HashSet<>(EdgeCollectionsInitialCapacity);            for (Map.Entry<Integer, Tile> entry : tileState.entrySet()){                if (entry.getValue().tileKind != TileKind.I) { refinedTileStateKeySet.add(entry.getKey()); }            }            for (int key : refinedTileStateKeySet){                if (! (checkedForce.contains(key))){                    ForceScorePath path = new ForceScorePath(0,0, checkedForce,key);                    path = path.calculate();                    if      (path.tileCountO > path.tileCountB) {                        scoreO += path.edgeCounterForce;                        edgesO.addAll(path.edgesOnPath);                    }                    else if (path.tileCountO < path.tileCountB) {                        scoreB += path.edgeCounterForce;                        edgesB.addAll(path.edgesOnPath);                    }                    checkedForce.addAll(path.checkedForce);                }            }            for (int node : availableNodes) {                if (checkedForce.contains(node)) continue;                EdgeType[] row = matrixEdgeEncode[node];                for (int other = 0; other < maxNodeID + 1; other++) {                    EdgeType tempEdgeType = row[other];                    if (tempEdgeType != EdgeType.FORCE) continue;   // Not force, not interested                    if (!tileState.containsKey(other)) continue;                    Tile tile = tileState.get(other);                    if (tile.tileKind != TileKind.I) continue;      // Not WEFT, not interested                    // so now found the missing edge that has a WEFT on one end (the other end empty)                    if (tile.player == Player.ORANGE) {                        scoreO++;                        edgesO.add(new Edge(EdgeType.FORCE, node, other));                    }                    else {                        scoreB++;                        edgesB.add(new Edge(EdgeType.FORCE, node, other));                    }                }                checkedForce.add(node);            }            // Check for the case of a FORCE edge between two WEFT            Set<Integer> checkedDuplicate = new HashSet<>(EdgeCollectionsInitialCapacity);            for (Map.Entry<Integer, Tile> entry : tileState.entrySet()){                int key = entry.getKey();                Tile tileReference = entry.getValue();                Player playerRef = tileReference.player;                if (tileReference.tileKind != TileKind.I) continue;  // Not WEFT, not interested                EdgeType[] row = matrixEdgeEncode[key];                for (int other = 0; other < maxNodeID + 1; other++){                    EdgeType tempEdgeType = row[other];                    if (checkedDuplicate.contains(other)) continue;                    if (tempEdgeType != EdgeType.FORCE) continue;   // Not FORCE edge, not interested                    if (! tileState.containsKey(other)) continue;   // No tiles here, not interested                    Tile tileOther = tileState.get(other);                    if (tileOther.tileKind != TileKind.I) continue; // The other one is not WEFT, skip                    if (tileOther.player == playerRef) {            // Good, finally found this devil!                        if (playerRef == Player.ORANGE) {                            scoreO++;                            edgesO.add(new Edge(EdgeType.FORCE, key, other));                        }                        else {                            scoreB++;                            edgesB.add(new Edge(EdgeType.FORCE, key, other));                        }                        checkedDuplicate.add(key);                        checkedDuplicate.add(other);                    } // else not equal, so they will cancel anyway                }            }        }    }    /**     * This contains a path of Force edges, use method calculate to initialise     * Works similarly (pretty much exactly) like StrengthScorePath     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    class ForceScorePath { // of one path only        int tileCountO;        int tileCountB;        final Set<Integer> checkedForce;        final int referenceNode;        int edgeCounterForce = 0;        final Set<Edge> edgesOnPath = new HashSet<>(EdgeCollectionsInitialCapacity);        ForceScorePath(int tileCountO, int tileCountB, Set<Integer> checkedForce, int referenceNode){            this.tileCountO = tileCountO;            this.tileCountB = tileCountB;            this.checkedForce = checkedForce;            this.referenceNode = referenceNode;            this.checkedForce.add(referenceNode);            Tile tempTile = tileState.get(referenceNode);  // this looks might throw an error, but should never happen            if      (tempTile.player == Player.ORANGE) this.tileCountO += 1;            else if (tempTile.player == Player.BLACK)  this.tileCountB += 1;            // else player == null, this is used for projection score calculations        }        @Override        public String toString() { return tileCountO + ", " + tileCountB + ", " + referenceNode + ", " + edgeCounterForce; }        ForceScorePath calculate(){            EdgeType[] row = matrixEdgeEncode[referenceNode];            EdgeType tempEdgeType;            ForceScorePath recursive;            for (int i = 0; i < maxNodeID+1; i++) {                tempEdgeType = row[i];                if (checkedForce.contains(i)) continue;                if (tempEdgeType != EdgeType.FORCE) continue;                edgeCounterForce++;                edgesOnPath.add(new Edge(tempEdgeType, referenceNode, i));                if (tileState.containsKey(i)) {                    Tile tempTile = tileState.get(i);                    if (tempTile.tileKind == TileKind.I) {                        if (tempTile.player == Player.ORANGE) this.tileCountO += 1;                        else if (tempTile.player == Player.BLACK) this.tileCountB += 1;                        else throw new RuntimeException("Unassigned Player in State");                    } else { // not a WEFT, then recurse down                        checkedForce.add(i);                        recursive = new ForceScorePath(tileCountO, tileCountB, checkedForce, i);                        recursive = recursive.calculate();                        checkedForce.addAll(recursive.checkedForce);                        edgeCounterForce += recursive.edgeCounterForce;                        edgesOnPath.addAll(recursive.edgesOnPath);                        tileCountO = recursive.tileCountO;                        tileCountB = recursive.tileCountB;                    }                }            }            return this;        }    }    /**     * This just return the first valid move (very very dumb)     * (Task 10)     * @param tiles a string representing one or two flipped playing tiles, as described in     * @return the first (random almost) valid move     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public Action simplyFirstMove(String tiles) {        Player player = Utility.charToPlayer(tiles.charAt(0));        Action action;        if (tiles.length() == 2) {            if (tiles.charAt(1) == 'j'){                ArrayList<Integer> warpList = getPossibleWarpNodes(availableNodes.get(0));                action = new Action(availableNodes.get(0), warpList.get(0), warpList.get(1), player);            } else {                action = new Action(Tile.charToTileKind(tiles.charAt(1)), availableNodes.get(0), player);            }        } else { // two tiles            if (tiles.charAt(1) == 'j' && tiles.charAt(3) == 'j') {                ArrayList<Integer> warpListA = getPossibleWarpNodes(availableNodes.get(0));                ArrayList<Integer> warpListB = getPossibleWarpNodes(availableNodes.get(1));                action = new Action(availableNodes.get(0), warpListA.get(0), warpListA.get(0),                        availableNodes.get(1), warpListB.get(0), warpListB.get(1), player);            } else if (tiles.charAt(1) == 'j'){                ArrayList<Integer> warpList = getPossibleWarpNodes(availableNodes.get(0));                action = new Action(availableNodes.get(0), warpList.get(0), warpList.get(1),                        Tile.charToTileKind(tiles.charAt(3)), availableNodes.get(1),  player);            } else if (tiles.charAt(3) == 'j') {                ArrayList<Integer> warpList = getPossibleWarpNodes(availableNodes.get(0));                action = new Action(Tile.charToTileKind(tiles.charAt(1)), availableNodes.get(1),                        availableNodes.get(0), warpList.get(0), warpList.get(1), player);            } else {                action = new Action(Tile.charToTileKind(tiles.charAt(1)), availableNodes.get(0),                        Tile.charToTileKind(tiles.charAt(3)), availableNodes.get(1), player);            }        }        return action;    }    /**     * Generate a (pruned) list of valid actions     * @param tilesSelected tiles given to the player     * @return a list of all valid actions     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    public ArrayList<Action> generateActionList(TilesSelected tilesSelected){        final Player player = tilesSelected.player;        if (tilesSelected.subTileSelectedB == null)  // One action case - easy            return generateSingleActionList(tilesSelected.subTileSelectedA, player);        // now, the nightmare case... :<        ArrayList<Action> output = new ArrayList<>(1000);        ArrayList<Action> firstBatch = generateSingleActionList(tilesSelected.subTileSelectedA, player);        for (Action firstAction : firstBatch){            AgamemnonState tempState = this.cloneIt();            tempState.applyAction(firstAction);            ArrayList<Action> theRest = tempState.generateSingleActionList(tilesSelected.subTileSelectedB, player);            for (Action secondAction : theRest){ output.add(firstAction.mergeAction(secondAction)); }        }        return output;    }    /**     * Generates a list of (sub) actions that places a single tile.     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    private ArrayList<Action> generateSingleActionList(TileKind tileKind, Player player){        // Note: SubTileSelected pretty much only contains        ArrayList<Action> output = new ArrayList<>(1000);        boolean stillNeedAtLeastOneUseless = true;        boolean noPruning = getCurrentTurn() > 10;  // for the sake of MonteCarlo to do some sampling        for (int id : this.availableNodes){            if (tileKind == TileKind.J) {                boolean needAUselessWarpAction = true;                ArrayList<Integer> possibleWarpNodes = getPossibleWarpNodes(id);                for (int warpIDA : possibleWarpNodes){                    ArrayList<Integer> again = new ArrayList<>(possibleWarpNodes);                    again.remove(Integer.valueOf(warpIDA));                    for (int warpIDB : again){                        if (isWarpActionUseless(id, warpIDA, warpIDB)) {                            if (needAUselessWarpAction){                                output.add(new Action(id, warpIDA, warpIDB, player));                                needAUselessWarpAction = false;                            }                            continue;                        }                        output.add(new Action(id, warpIDA, warpIDB, player));                    }                }            } else {                if (stillNeedAtLeastOneUseless || tileInteractsHere(id, tileKind.data.type) || noPruning){                    stillNeedAtLeastOneUseless = false;                    output.add(new Action(tileKind, id , player));                }            }        }        return output;    }    /**     * Does this tile doing any purpose here     * @param nodeID nodeID proposed to be placing this tile     * @param tileType the Tile type     * @return true if the tile can interact with edges on this node     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    private boolean tileInteractsHere(int nodeID, TileType tileType) {        if (tileType == TileType.WEFT || tileType == TileType.WARP) return true; // weaver tiles interacts with everything        EdgeType[] row = matrixEdgeEncode[nodeID];        int counter_S = 0;  // Strength        int counter_L = 0;  // Leadership        for (EdgeType edgeType : row){            if (edgeType == null) continue;            switch (edgeType) {                case FORCE:         return true; // Force edges interact with everything                case STRENGTH:      if(tileType ==  TileType.LEADER || tileType == TileType.WARRIOR) return true;                                    else { counter_S++; break; }                case LEADERSHIP:    if(tileType == TileType.LEADER) return true;                                    else { counter_L++; break; }            }        }        return counter_S > 1 || counter_L > 1; // although they don't interact, but it may enable connections    }    public ArrayList<Integer> getPossibleWarpNodes(int nodeID){        ArrayList<Integer> output = new ArrayList<>(7);        for (Edge edge : edgeState){            if (edge.contains(nodeID)){ output.add(edge.theOtherID(nodeID)); }        }        return output;    }    /**     * Does this warp action do anything here     * @param center the node where the warp tile is placed     * @param warpIDA first warp id     * @param warpIDB second warp id     * @return true is the two edges are the same, i.e. the warp is not doing anything     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    private boolean isWarpActionUseless(int center, int warpIDA, int warpIDB){        EdgeType edgeTypeA = findMeThisEdge(center, warpIDA);        EdgeType edgeTypeB = findMeThisEdge(center, warpIDB);        return edgeTypeA == edgeTypeB;    }    /**     * Given nodeA nodeB, return the EdgeType connecting the two nodes     * @param nodeA first node     * @param nodeB second node     * @return the edge that connects nodeA and nodeB, if null then return null     * (c) XinTong (Tony) Yan (u6966927@ANU) 2019 All right reserved     */    private EdgeType findMeThisEdge(int nodeA, int nodeB){        return matrixEdgeEncode[nodeA][nodeB];    }}